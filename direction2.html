<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Para la mas bonitaüíï‚ú®</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚ù§Ô∏è</text></svg>">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Amatic+SC:wght@400;700&display=swap');

        /* ===== M√ìDULO DE COLORES PERSONALIZABLE ===== */
        :root {
            /* Colores de fuegos artificiales - Edita estos valores para cambiar los colores */
            --firework-pink: 255, 100, 150;
            --firework-blue: 100, 150, 255;
            --firework-gold: 255, 200, 100;
            --firework-green: 150, 255, 150;
            --firework-orange: 255, 150, 100;
            --firework-purple: 200, 100, 255;
            --firework-yellow: 255, 255, 100;
            --firework-cyan: 100, 255, 255;
            --firework-red: 255, 100, 100;
            --firework-white: 255, 255, 255;
            
            /* Colores del fondo y texto (no modificar a menos que sepas lo que haces) */
            --bg-gradient-start: #1a1a2e;
            --bg-gradient-middle: #162447;
            --bg-gradient-end: #e94560;
            --text-color: #fff;
            --heart-color: #ff6b6b;
            --sparkle-color: #ffd700;
        }
        /* ===== FIN M√ìDULO DE COLORES ===== */

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Amatic SC', cursive;
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: linear-gradient(to bottom, var(--bg-gradient-start) 0%, var(--bg-gradient-middle) 50%, var(--bg-gradient-end) 100%);
            cursor: pointer;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .message-container {
            position: relative;
            z-index: 2;
            text-align: center;
            width: 95%;
            max-width: 1200px;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
        }

        .message {
            font-size: clamp(4rem, 8vw, 8rem);
            font-weight: 700;
            opacity: 0;
            position: absolute;
            transform: translateY(50px);
            text-shadow: 0 0 20px rgba(255,255,255,0.9),
                        0 0 40px rgba(255,255,255,0.6),
                        0 0 60px rgba(255,255,255,0.3);
            width: 100%;
            line-height: 1.2;
            letter-spacing: 0.02em;
        }

        /* Estilos para mensajes flotantes al hacer clic */
        .floating-message {
            position: absolute;
            font-size: 1.8rem;
            font-weight: 700;
            color: white;
            text-shadow: 0 0 10px rgba(255,255,255,0.8),
                         0 0 20px rgba(255,255,255,0.6);
            pointer-events: none;
            z-index: 100;
            opacity: 0;
            white-space: nowrap;
            animation: floatUp 2s ease-out forwards;
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-80px) scale(1.2);
            }
        }

        @keyframes fadeInOut {
            0% { 
                opacity: 0; 
                transform: translateY(20px); 
            }
            10% { 
                opacity: 1; 
                transform: translateY(0); 
            }
            80% { 
                opacity: 1;  /* Mantiene visible hasta el 80% */
            }
            90% { 
                opacity: 0;  /* Se desvanece r√°pido en el 90% */
                transform: translateY(-20px); 
            }
            100% { 
                opacity: 0; 
            }
        }

        .heart {
            display: inline-block;
            color: var(--heart-color);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        .sparkle {
            display: inline-block;
            color: var(--sparkle-color);
            animation: sparkle 1.8s infinite;
        }

        @keyframes sparkle {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .click-instruction {
            display: none;
        }

        @media (max-width: 768px) {
            .message {
                font-size: clamp(4.1rem, 7vw, 6rem);
            }
            .message-container {
                width: 98%;
                align-items: flex-start;
                padding-top: 78vh;
            }
        }

        @media (max-width: 480px) {
            .message {
                font-size: clamp(3.6rem, 6vw, 5rem);
            }
            .message-container {
                padding-top: 75vh;
            }
        }
        .static-message {
            font-size: clamp(3rem, 6vw, 6rem);
            font-weight: 700;
            opacity: 0;
            position: absolute;
            text-shadow: 0 0 20px rgba(255,255,255,0.9),
                        0 0 40px rgba(255,255,255,0.6),
                        0 0 60px rgba(255,255,255,0.3);
            width: 100%;
            line-height: 1.2;
            letter-spacing: 0.02em;
            animation: appearFinal 1s ease-in-out forwards;
            animation-delay: calc(29 * 4.5s); /* 29 mensajes √ó 4.5s cada uno */
        }

        @keyframes appearFinal {
            0% { 
                opacity: 0; 
                transform: translateY(20px); 
            }
            100% { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }
        .return-link {
            display: inline-block;
            margin-top: 20px;
            font-size: 2.5rem;
            color: var(--heart-color);
            text-decoration: none;
            padding: 10px 30px;
            border: 2px solid var(--heart-color);
            border-radius: 50px;
            background: rgba(255, 107, 107, 0.1);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            animation: pulse 2s infinite;
        }

        .return-link:hover {
            background: rgba(255, 107, 107, 0.3);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }
    </style>
</head>

<body>
    <!-- Overlay de activaci√≥n -->
    <div id="music-overlay" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        font-family: 'Amatic SC', cursive;
        color: white;
        text-align: center;
    ">
        <div style="font-size: 3rem; cursor: pointer;">
            ‚ú® Toca para activar la m√∫sica y/o los fuegos artificiales‚ú®<br>Lamento que las pistas se me hayan corrompido :c
        </div>
    </div>
    
    <canvas id="starrySky"></canvas>
    <div class="message-container">
        <div class="message">Hola Pris</div>
        <div class="message">Nuevamente te quiero pedir perdon <span class="sparkle">ü•≤</span></div>
        <div class="message">Yo se en todo lo que la he cagado</div>
        <div class="message">De verdad no te mereciste nada de eso</div>
        <div class="message">Sin embargo aun te amo</div>
        <div class="message">Me muero por tener tu amor</div>
        <div class="message">Me muero por regresar contigo</div>
        <div class="message">Por tener de vuelta esos ojitos bonitos</div>
        <div class="message">Por tener de vuelta esa risa tan hermosa</div>
        <div class="message">A quien hace mis dias tan felices</div>
        <div class="message">Extra√±o esos ojos so√±adores</div>
        <div class="message">Gigantes y grande</div>
        <div class="message">Extra√±o ese cabello lacio y negrito</div>
        <div class="message">Extra√±o a esa doctora tan chistosa</div>
        <div class="message">Extra√±o tus cartitas</div>
        <div class="message">Extra√±o tus buenos dias</div>
        <div class="message">Extra√±o tus buenas noches</div>
        <div class="message">Cuando me decias que me amabas</div>
        <div class="message">Nunca olvidare todo lo hermoso</div>
        <div class="message">Me arrepentire cada dia de mi vida</div>
        <div class="message">Me duele no tenerte</div>
        <div class="message">Me duele no estar a tu lado</div>
        <div class="message">Me quema que ya no me quieras</div>
        <div class="message">Este amor me esta matando</div>
        <div class="message">Hare todo por recuperarte Pris</div>
        <div class="message">Te amo mucho amor</div>
        <div class="message">Y ESO NUNCA LO OLVIDES</div>
        <div class="message"><span class="heart">üíû</span></div>
        <!-- NUEVO DIV EST√ÅTICO -->
        <div id="final-message" class="static-message">
            -De Sam para Pris, Te amo.<br>
            <a href="index.html" class="return-link">Volver al inicio -></a>
        </div>
    </div>
    <div class="click-instruction">Haz clic para crear fuegos artificiales üéÜ</div>

    <script>
        const canvas = document.getElementById('starrySky');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();

        const stars = [];
        const shootingStars = [];
        const fireworks = [];
        const particles = [];

        let lastFireworkTime = 0;
        const fireworkCooldown = 300; // 300ms entre fuegos artificiales
        
        // Sistema de m√∫sica robusto - MODIFICADO para inicializar en el primer clic
        let audio = null;
        let audioContext = null;
        let isAudioInitialized = false; // Bandera para saber si ya se intent√≥ inicializar el audio
        let audioAttempts = 0;
        const maxAudioAttempts = 5;

        // Arreglo de mensajes aleatorios
        const randomMessages = [
            "üíñ Te amo",
            "‚ú® Eres incre√≠ble",
            "üåπ Para la m√°s bonita",
            "üí´ Aun eres mi princesa",
            "üîÆ Eres Genial",
            "üå∏ Tu carisma me mata",
            "üñï CTM JESUS",
            "üåü Brillas como estrella",
            "üñï CTM ABRAHAM",
            "üñï CTM SAMUEL",
            "üñï CTM ILCE",
            "üíò Te extra√±o",
            "üíù Gracias por todo",
            "üíó Me encantas",
            "‚ù§Ô∏è‚Äçüî• Loco por ti",
            "üíì Me muero por ti",
            "üíå Para ti siempre",
            "üéá Quiero estar contigo",
            "ü´∂ Otra oportunidad, otra oportunidad",
            "üíü Pris hermosa"
        ];

        // Funci√≥n para crear mensaje flotante
        function createFloatingMessage(x, y) {
            const randomIndex = Math.floor(Math.random() * randomMessages.length);
            const messageText = randomMessages[randomIndex];
            
            const floatingMsg = document.createElement('div');
            floatingMsg.className = 'floating-message';
            floatingMsg.textContent = messageText;
            floatingMsg.style.left = x + 'px';
            floatingMsg.style.top = y + 'px';
            
            document.body.appendChild(floatingMsg);
            
            // Eliminar el elemento despu√©s de la animaci√≥n
            setTimeout(() => {
                if (floatingMsg.parentNode) {
                    floatingMsg.parentNode.removeChild(floatingMsg);
                }
            }, 2000);
        }

        // Obtener colores CSS personalizables
        function getCSSColor(colorVar) {
            const style = getComputedStyle(document.documentElement);
            const colorString = style.getPropertyValue(colorVar).trim();
            return colorString.split(',').map(c => parseInt(c.trim()));
        }

        // Nueva funci√≥n para crear y reproducir audio, llamada solo en interacci√≥n del usuario
        function createAndPlayAudio() {
            if (isAudioInitialized) return; // Ya se intent√≥ inicializar, no lo hagas de nuevo aqu√≠

            audioAttempts++;
            if (audioAttempts > maxAudioAttempts) {
                console.log('M√°ximo de intentos de audio alcanzado. Puede que el audio no se reproduzca.');
                return;
            }
            
            try {
                // Solo crea AudioContext y el elemento de audio una vez
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    audio = new Audio();
                    audio.src = 'Eso_nunca_FINAL.mp3';
                    audio.loop = true;
                    audio.volume = 0.7;
                    audio.preload = 'auto';
                    
                    audio.addEventListener('canplaythrough', () => {
                        console.log('Audio listo para reproducir');
                    });
                    
                    audio.addEventListener('error', (e) => {
                        console.log('Error de audio:', e);
                        // Reiniciar isAudioInitialized si hay un error para permitir reintentos
                        isAudioInitialized = false; 
                    });
                }
                
                // Aseg√∫rate de reanudar el AudioContext si est√° suspendido
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                // Intentar reproducir
                const playPromise = audio.play();
                
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => {
                            console.log('M√∫sica iniciada correctamente');
                            isAudioInitialized = true; // Audio inicializado y reproduci√©ndose
                        })
                        .catch((error) => {
                            console.log('Error al reproducir:', error);
                            // No marcar como inicializado si hay un error en la reproducci√≥n
                            // El pr√≥ximo clic lo intentar√° de nuevo si audioAttempts < maxAudioAttempts
                        });
                } else {
                    // Para navegadores antiguos sin Promise en audio.play()
                    console.log('Reproducci√≥n de audio iniciada (sin promesa).');
                    isAudioInitialized = true;
                }
                
            } catch (error) {
                console.log('Error al inicializar o reproducir audio:', error);
                // Si hay un error general en la inicializaci√≥n, permitir reintentos
                isAudioInitialized = false; 
            }
        }

        // Funci√≥n para reanudar audio si se paus√≥ (por cambio de tab, etc.)
        function resumeAudio() {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            // Solo intentar play si el audio existe y est√° pausado
            if (audio && audio.paused && isAudioInitialized) {
                audio.play().catch(e => console.log('Error al reanudar:', e));
            }
        }

        class Star {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.radius = Math.random() * 1.8;
                this.opacity = Math.random() * 0.6 + 0.4;
                this.twinkleSpeed = Math.random() * 0.02 + 0.01;
                this.twinklePhase = Math.random() * Math.PI * 2;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity * (Math.sin(Date.now() * this.twinkleSpeed + this.twinklePhase) * 0.4 + 0.8)})`;
                ctx.fill();
            }
        }

        class ShootingStar {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * canvas.width;
                this.y = 0;
                this.length = Math.random()*60+60;
                this.speed = Math.random()*3+3;
                this.angle = Math.PI/4;
                this.opacity = 1;
            }

            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                this.opacity -= 0.015;
                if (this.opacity <= 0) {
                    this.reset();
                }
            }

            draw() {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - Math.cos(this.angle) * this.length, this.y - Math.sin(this.angle) * this.length);
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.lineWidth = 2.5;
                ctx.stroke();
            }
        }

        class Firework {
            constructor(x, y) {
                this.x = x;
                this.y = canvas.height;
                this.targetX = x;
                this.targetY = y;
                this.speed = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ? 5 : 8;
                this.exploded = false;
                this.particles = [];
                this.trail = [];
                this.color = this.getRandomColor();
            }

            getRandomColor() {
                const colorVars = [
                    '--firework-pink', '--firework-blue', '--firework-gold', 
                    '--firework-green', '--firework-orange', '--firework-purple', 
                    '--firework-yellow', '--firework-cyan', '--firework-red', '--firework-white'
                ];
                const randomVar = colorVars[Math.floor(Math.random() * colorVars.length)];
                return getCSSColor(randomVar);
            }

            update() {
                if (!this.exploded) {
                    this.trail.push({ x: this.x, y: this.y });
                    if (this.trail.length > 10) this.trail.shift();
                    
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > this.speed) {
                        this.x += (dx / distance) * this.speed;
                        this.y += (dy / distance) * this.speed;
                    } else {
                        this.x = this.targetX;
                        this.y = this.targetY;
                        this.explode();
                    }
                } else {
                    this.particles.forEach((particle, index) => {
                        particle.update();
                        if (particle.life <= 0) {
                            this.particles.splice(index, 1);
                        }
                    });
                }
            }

            explode() {
                this.exploded = true;
                const particleCount = Math.random() * 40 + 60;
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 * i) / particleCount;
                    const velocity = Math.random() * 2 + 1;
                    
                    this.particles.push(new Particle(
                        this.x,
                        this.y,
                        Math.cos(angle) * velocity,
                        Math.sin(angle) * velocity,
                        this.color
                    ));
                }
            }

            draw() {
                if (!this.exploded) {
                    // Dibujar rastro con brillo ne√≥n
                    this.trail.forEach((point, index) => {
                        const opacity = index / this.trail.length;
                        
                        // Brillo exterior ne√≥n
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, ${opacity * 0.3})`;
                        ctx.fill();
                        
                        // N√∫cleo brillante
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 2, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, ${opacity})`;
                        ctx.fill();
                    });

                    // Cohete con efecto ne√≥n mejorado
                    this.drawNeonCircle(this.x, this.y, 5, this.color, 1);
                } else {
                    this.particles.forEach(particle => particle.draw());
                }
            }

            drawNeonCircle(x, y, radius, color, opacity) {
                // M√∫ltiples capas para efecto ne√≥n ultra brillante
                const layers = [
                    { radius: radius * 3, opacity: opacity * 0.08 },
                    { radius: radius * 2.5, opacity: opacity * 0.15 },
                    { radius: radius * 2, opacity: opacity * 0.25 },
                    { radius: radius * 1.5, opacity: opacity * 0.4 },
                    { radius: radius * 1.2, opacity: opacity * 0.6 },
                    { radius: radius, opacity: opacity * 0.9 },
                    { radius: radius * 0.7, opacity: opacity },
                    { radius: radius * 0.4, opacity: opacity * 1.2 }
                ];

                layers.forEach(layer => {
                    ctx.beginPath();
                    ctx.arc(x, y, layer.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${Math.min(layer.opacity, 1)})`;
                    ctx.fill();
                });
                
                // N√∫cleo ultra brillante blanco
                ctx.beginPath();
                ctx.arc(x, y, radius * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
                ctx.fill();
            }

            isDead() {
                return this.exploded && this.particles.length === 0;
            }
        }

        class Particle {
            constructor(x, y, vx, vy, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = 1;
                this.decay = Math.random() * 0.015 + 0.008;
                this.gravity = 0.03;
                this.length = Math.random() * 15 + 10;
                this.prevX = x;
                this.prevY = y;
                this.brightness = Math.random() * 0.7 + 0.8; // Brillo m√°s intenso
            }

            update() {
                this.prevX = this.x;
                this.prevY = this.y;
                
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.vx *= 0.985;
                this.life -= this.decay;
            }

            draw() {
                const dx = this.x - this.prevX;
                const dy = this.y - this.prevY;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length > 0) {
                    const unitX = dx / length;
                    const unitY = dy / length;
                    
                    const endX = this.x - unitX * this.length;
                    const endY = this.y - unitY * this.length;
                    
                    // Gradiente ne√≥n ultra brillante
                    const gradient = ctx.createLinearGradient(this.x, this.y, endX, endY);
                    const baseOpacity = this.life * this.brightness;
                    
                    gradient.addColorStop(0, `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, ${baseOpacity * 1.2})`);
                    gradient.addColorStop(0.5, `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, ${baseOpacity * 0.8})`);
                    gradient.addColorStop(1, `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, 0)`);
                    
                    // Brillo exterior ultra intenso
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, ${baseOpacity * 0.15})`;
                    ctx.lineWidth = 8;
                    ctx.stroke();
                    
                    // Brillo medio
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, ${baseOpacity * 0.4})`;
                    ctx.lineWidth = 5;
                    ctx.stroke();
                    
                    // L√≠nea principal brillante
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 2.5;
                    ctx.stroke();
                    
                    // Punto brillante con m√∫ltiples capas ne√≥n
                    this.drawNeonPoint(this.x, this.y, baseOpacity);
                }
            }

            drawNeonPoint(x, y, opacity) {
                // Efecto ne√≥n ultra brillante con m√∫ltiples capas
                const layers = [
                    { radius: 10, opacity: opacity * 0.08 },
                    { radius: 8, opacity: opacity * 0.15 },
                    { radius: 6, opacity: opacity * 0.25 },
                    { radius: 4, opacity: opacity * 0.4 },
                    { radius: 3, opacity: opacity * 0.6 },
                    { radius: 2, opacity: opacity * 0.8 },
                    { radius: 1.5, opacity: opacity },
                    { radius: 1, opacity: opacity * 1.2 }
                ];

                layers.forEach(layer => {
                    ctx.beginPath();
                    ctx.arc(x, y, layer.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, ${Math.min(layer.opacity, 1)})`;
                    ctx.fill();
                });
                
                // N√∫cleo blanco ultra brillante
                ctx.beginPath();
                ctx.arc(x, y, 0.8, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.min(opacity * 1.5, 1)})`;
                ctx.fill();
                
                // Destello adicional
                ctx.beginPath();
                ctx.arc(x, y, 0.3, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.min(opacity * 2, 1)})`;
                ctx.fill();
            }
        }

        // Inicializar estrellas
        for (let i = 0; i < 250; i++) {
            stars.push(new Star());
        }

        // Inicializar estrellas fugaces
        for (let i = 0; i < 4; i++) {
            shootingStars.push(new ShootingStar());
        }

        // Event listener para fuegos artificiales y m√∫sica
        document.addEventListener('click', (e) => {
            createAndPlayAudio();
            resumeAudio();
            
            const x = e.clientX;
            const y = e.clientY;
            
            // Crear mensaje flotante en cada clic
            createFloatingMessage(x, y);
            
            // Crear fuego artificial (con cooldown)
            const currentTime = Date.now();
            if (currentTime - lastFireworkTime > fireworkCooldown) {
                fireworks.push(new Firework(x, y));
                lastFireworkTime = currentTime;
            }
        });

        // Tambi√©n funciona en m√≥viles
        document.addEventListener('touchstart', (e) => {
            e.preventDefault();
            
            createAndPlayAudio();
            resumeAudio();
            
            const touch = e.touches[0];
            const x = touch.clientX;
            const y = touch.clientY;
            
            // Crear mensaje flotante en cada toque
            createFloatingMessage(x, y);
            
            const currentTime = Date.now();
            if (currentTime - lastFireworkTime > fireworkCooldown) {
                fireworks.push(new Firework(x, y));
                lastFireworkTime = currentTime;
            }
        });

        document.addEventListener('touchend', (e) => {
            e.preventDefault();
            resumeAudio(); // Solo reanudar, no crear AudioContext nuevamente
        });

        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && audio && !audio.paused) {
                resumeAudio();
            }
        });

        window.addEventListener('focus', () => {
            resumeAudio();
        });

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Dibujar estrellas
            stars.forEach(star => star.draw());
            
            // Dibujar estrellas fugaces
            shootingStars.forEach(star => {
                star.update();
                star.draw();
            });
            
            // Dibujar fuegos artificiales
            fireworks.forEach((firework, index) => {
                firework.update();
                firework.draw();
                
                if (firework.isDead()) {
                    fireworks.splice(index, 1);
                }
            });
            
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            resizeCanvas();
            stars.forEach(star => {
                if (star.x > canvas.width) star.x = canvas.width;
                if (star.y > canvas.height) star.y = canvas.height;
            });
        });

        animate();
    </script>
    <script>
        const messages = document.querySelectorAll(".message");
        const messageDuration = 4.5;

        messages.forEach((msg, index) => {
            const delay = index * messageDuration;
            
            if (index < messages.length - 1) {
                msg.style.animation = `fadeInOut ${messageDuration}s ease-in-out ${delay}s 1 forwards`;
            } else {
                // Usar fadeInOut normal pero modificar para que no desaparezca
                msg.style.animation = `fadeInStay ${messageDuration}s ease-in-out ${delay}s 1 forwards`;
            }
        });

        // Crear animaci√≥n que se queda visible
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeInStay {
                0% { opacity: 0; transform: translateY(20px); }
                20% { opacity: 1; transform: translateY(0); }
                100% { opacity: 1; transform: translateY(0); }
            }
        `;
        document.head.appendChild(style);
    </script>

    <script>
        document.getElementById('music-overlay').addEventListener('click', function() {
            createAndPlayAudio();
            this.style.display = 'none';
        });
    </script>

</body>
</html>